CREATE TABLE DEPARTMENT
(
    DEPT_ID CHAR(2),
    DEPT_TITLE VARCHAR2 (35),
    LOCATION_ID CHAR(2)
);
SELECT * FROM DEPARTMENT;
INSERT INTO DEPARTMENT(dept_id, dept_title, location_id)
VALUES('D1', '인사관리부', 'L1');
COMMENT ON COLUMN DEPARTMENT.DEPT_ID IS '부서코드';
--==================================
DROP TABLE EMPLOYEE;
CREATE TABLE EMPLOYEE
(
    EMP_ID VARCHAR2 (3),
    EMP_NAME VARCHAR2 (20),
    EMP_NO CHAR (14),
    EMAIL VARCHAR2 (25),
    PHONE VARCHAR2 (12),
    DEPT_CODE CHAR (2),
    JOB_CODE CHAR (2),
    SAL_LEVEL CHAR (2),
    SALARY NUMBER,
    BONUS NUMBER,
    MANAGER_ID VARCHAR(3),
    HIRE_DATE DATE,
    ENT_DATE DATE,
    ENT_YN  CHAR(1),
    CONSTRAINT UNQ_EMP_ID UNIQUE(EMP_ID)
);
COMMENT ON COLUMN EMPLOYEE.EMP_ID IS '사원번호';
COMMENT ON COLUMN EMPLOYEE.EMP_NAME IS '직원명';
COMMENT ON COLUMN EMPLOYEE.EMP_NO IS '주민등록번호';
COMMENT ON COLUMN EMPLOYEE.EMAIL IS '이메일';
COMMENT ON COLUMN EMPLOYEE.PHONE IS '전화번호';
COMMENT ON COLUMN EMPLOYEE.DEPT_CODE IS '부서코드';
COMMENT ON COLUMN EMPLOYEE.JOB_CODE IS '직급코드';
COMMENT ON COLUMN EMPLOYEE.SAL_LEVEL IS '급여등급';
COMMENT ON COLUMN EMPLOYEE.SALARY IS '급여';
COMMENT ON COLUMN EMPLOYEE.BONUS IS '보너스율';
COMMENT ON COLUMN EMPLOYEE.MANAGER_ID IS '관리자사번';
COMMENT ON COLUMN EMPLOYEE.HIRE_DATE IS '입사일';
COMMENT ON COLUMN EMPLOYEE.ENT_DATE IS '퇴사일';
COMMENT ON COLUMN EMPLOYEE.ENT_YN IS '퇴직여부';

-- ==============JOB TABLE ================
CREATE TABLE JOB 
(
    JOB_CODE CHAR(2),
    JOB_NAME VARCHAR2(35)
);
INSERT INTO JOB
VALUES('J1','대표');

COMMENT ON COLUMN JOB.JOB_CODE IS '직급코드';
COMMENT ON COLUMN JOB.JOB_NAME IS '직급명';

DELETE FROM JOB WHERE JOB_CODE = 'J1';
DELETE FROM JOB WHERE JOB_CODE = 'K1';
UPDATE JOB SET JOB_CODE = 'K1' WHERE JOB_CODE = 'J1';

SELECT * FROM JOB;
--===========================================
CREATE TABLE USER_NO_CONSTRAINT_NOTNULL
(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR(50)
);
INSERT INTO USER_NO_CONSTRAINT
VALUES(1,'khuser01','pass01','일용자','남','01082827373','khuser01@kh.com');
select *  from user_no_constraint;
INSERT INTO user_no_constraint_notnull
VALUES(1,NULL,'pass01','일용자','남','01082827373','khuser01@kh.com');
--========================== UNIQUE
CREATE TABLE USER_NO_CONSTRAINT_UNIQUE
(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR(50)
);
-- UNIQUE는 NULL값을 허용한다
INSERT INTO USER_NO_CONSTRAINT_UNIQUE
VALUES(1,NULL,'pass01','일용자','남','01082827373','khuser01@kh.com');
select * from USER_NO_CONSTRAINT_UNIQUE;
--========================= PRIMARY EKY
CREATE TABLE USER_PRIMARY_KEY
(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR(50)
);
INSERT INTO USER_PRIMARY_KEY
VALUES(1,NULL,'pass01','일용자','남','01082827373','khuser01@kh.com');
INSERT INTO USER_PRIMARY_KEY
VALUES(1,'khuser01','pass01','일용자','남','01082827373','khuser01@kh.com');
select *  from USER_PRIMARY_KEY;
--==========================CHECK , GENDER '남'오류
CREATE TABLE USER_CHECK
(
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) CONSTRAINT PK_USER_ID PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M','F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR(50)
);
select *  from USER_CHECK;
INSERT INTO USER_CHECK
VALUES(1,'khuser01','pass01','일용자','M','01082827373','khuser01@kh.com');
--===============================DEFALUT
CREATE TABLE USER_DEFAULT
(
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M','F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR(50),
    USER_DATE DATE DEFAULT SYSDATE
);
INSERT INTO USER_DEFAULT
VALUES(1,'khuser01','pass01','일용자','M','01082827373','khuser01@kh.com','23/12/07');
INSERT INTO USER_DEFAULT
VALUES(2,'khuser02','pass01','D용자','M','01082827373','khuser01@kh.com',DEFAULT);
SELECT * FROM USER_DEFAULT;
-- DEFALUT 제약조건은 기본값을 설정할 때 사용하고 DEFAULT를 쓰면 다른 것을 신경쓰지않고 데이터를 넣을 수 있다.
-- FOREIGN KEY 외래키
CREATE TABLE USER_GRADE
(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO USER_GRADE VALUES(10, '일반회원');
INSERT INTO USER_GRADE VALUES(20, '우수회원');
INSERT INTO USER_GRADE VALUES(30, '특별회원');
SELECT * FROM USER_GRADE;
-- 현재 테이블은 부모 테이블. 자식테이블의 한 컬럼이 부모테이블을 참조함
CREATE TABLE USER_FOREIGNKEY
(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M','F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR(50),
    USER_DATE DATE DEFAULT SYSDATE,
    GRADE_CODE NUMBER REFERENCES USER_GRADE(GRADE_CODE) ON DELETE SET NULL
);
-- 자식 테이블에서 insert 할때 부모 테이블이 가지고 있는 컬럼의 필드값으로만 insert가
-- 되도록 함. 부모테이블에서 데이터를 함부로 지우지 못하게 함
SELECT * FROM USER_FOREIGNKEY;
INSERT INTO USER_FOREIGNKEY
VALUES(1,'khuser01','pass01','D용자','M','01082827373','khuser01@kh.com',DEFAULT,10);
INSERT INTO USER_FOREIGNKEY
VALUES(2,'khuser02','pass01','D용자','M','01082827373','khuser01@kh.com',DEFAULT,20);
-- 외래키 예제 +
-- SHOP 고객 테이블, SHOP_MEMBER (부모)
-- SHOW 구매 내역 테이블, SHOP_BUY (자식)
CREATE TABLE SHOP_MEMBER
(
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M','F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR(50)
);
INSERT INTO SHOP_MEMBER
VALUES(1,'khuser01','pass01','1용자','M','01082827373','khuser01@kh.com');
INSERT INTO SHOP_MEMBER
VALUES(2,'khuser02','pass02','2용자','M','01082827373','khuser02@kh.com');
INSERT INTO SHOP_MEMBER
VALUES(3,'khuser03','pass03','3용자','M','01082827373','khuser03@kh.com');

CREATE TABLE SHOP_BUY
(
    BUY_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(30) REFERENCES SHOP_MEMBER(USER_ID),
    PRODUCT_NAME VARCHAR2(20),
    REG_DATE DATE DEFAULT SYSDATE
);
INSERT INTO SHOP_BUY
VALUES(1,'khuser01','농구화',DEFAULT);
INSERT INTO SHOP_BUY
VALUES(2,'khuser02','축구화',DEFAULT);
INSERT INTO SHOP_BUY
VALUES(3,'khuser03','배구화',DEFAULT);
INSERT INTO SHOP_BUY
VALUES(4,'khuser04','족구화',DEFAULT);
-- ORA-02291: 무결성 제약조건(KH.SYS_C007333)이 위배되었습니다- 부모 키가 없습니다
-- 외래키 제약조건에 걸림. 부모가 가지고 있는 컬럼의 값(필드)중 값을 적어야 한다.
ROLLBACK;
COMMIT;
-- 참조 무결성을 보장하기 위해 삭제 불가, 부모테이블의 데이터 삭제 불가
DELETE FROM USER_GRADE WHERE GRADE_CODE = 10;
-- 그럼에도 삭제를 허용해야 하는 경우가 있다. 그러기 위해 삭제 옵션을 외래키 설정시
-- 같이 설정해 주어야 한다.
-- 1. 기본 옵션 ON DELETE RESTRICTED
-- 2. 연관된 모든 것 삭제 옵션 ON DELETE CASCADE
-- 3. NULL로 만드는 옵션, ON DELETE SET NULL(부모는 삭제되고, 자식에 남아있는 데이터는 NULL로
-- > 해당 옵션은 외래키 설정시에 같이 적어주어야 적용됨.
DROP TABLE USER_FOREIGNKEY;